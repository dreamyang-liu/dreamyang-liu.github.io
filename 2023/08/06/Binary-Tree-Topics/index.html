<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>Binary Tree Topics | Tuntun&#39;s Blog</title>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">

  <!-- 添加代码高亮样式 -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
  <!-- 添加highlight.js库 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>  <link rel="stylesheet" href="/css/code.css">
  <link rel="stylesheet" href="/css/code-custom.css">
  <link rel="stylesheet" href="/css/code-languages.css">

  <link rel="stylesheet" href="/css/vscode.css">
  <link rel="stylesheet" href="/css/post.css">
  <link rel="stylesheet" href="/css/tag.css">
  <link rel="stylesheet" href="/css/categories.css">
  <link rel="stylesheet" href="/css/archive.css">
  <link rel="stylesheet" href="/css/search.css">
  <link rel="stylesheet" href="/css/mobile.css">  <link rel="stylesheet" href="/css/responsive.css">
  <link rel="stylesheet" href="/css/elements.css">

  <!-- 添加 JetBrains Mono 字体 -->  
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

  <!-- Add any custom head content here -->

  <script src="/js/explorer.js"></script>
  <script src="/js/code-copy.js"></script>
  <script src="/js/code-enhance.js"></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>


  <body>
    <div class="wrapper">
      <div class="mobile-menu-toggle">
        <i class="fas fa-bars"></i>
      </div>
      <header class="vs-header">
  <nav class="vs-nav">
    <div class="nav-left">
      <a href="/" class="nav-brand">
        <i class="fas fa-terminal"></i>
        Tuntun&#39;s Blog
      </a>
    </div>
    
    <div class="nav-right">
      <a href="/" class="nav-item ">
        <i class="fas fa-home"></i>
        <span>Home</span>
      </a>
      <a href="/archives/" class="nav-item ">
        <i class="fas fa-archive"></i>
        <span>Archives</span>
      </a>
      <a href="/categories/" class="nav-item ">
        <i class="fas fa-folder"></i>
        <span>Categories</span>
      </a>
      <a href="/tags/" class="nav-item ">
        <i class="fas fa-tags"></i>
        <span>Tags</span>
      </a>
      <a href="/search/" class="nav-item ">
        <i class="fas fa-search"></i>
        <span>Search</span>
      </a>
      <a href="/about/" class="nav-item ">
        <i class="fas fa-info-circle"></i>
        <span>About</span>
      </a>
    </div>
  </nav>
</header>

<script>
  function smoothScroll(event, target) {
    event.preventDefault();
    const targetId = target.substring(target.indexOf('#') + 1);
    const targetElement = document.getElementById(targetId);

    if (targetElement) {
      window.scrollTo({
        top: targetElement.offsetTop - 50, // 调整偏移量
        behavior: 'smooth'
      });
    } else {
      window.location.href = target;
    }
  }

  window.addEventListener('scroll', function() {
    const header = document.querySelector('.vs-header');
    const nav = document.querySelector('.vs-nav');
    const scrollPercent = (window.scrollY / (document.documentElement.scrollHeight - window.innerHeight)) * 100;
    
    nav.style.setProperty('--scroll-percent', `${scrollPercent}%`);
    
    if (window.scrollY > 0) {
      header.classList.add('scrolled');
    } else {
      header.classList.remove('scrolled');
    }
  });

  // 添加标签页切换动画
  document.querySelectorAll('.nav-item').forEach(item => {
    item.addEventListener('click', function(e) {
      const ripple = document.createElement('span');
      ripple.classList.add('nav-ripple');
      this.appendChild(ripple);
      
      const rect = this.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      ripple.style.left = `${x}px`;
      ripple.style.top = `${y}px`;
      
      setTimeout(() => ripple.remove(), 1000);
    });
  });
</script>


<div class="vscode-container">
  <!-- 左侧资源管理器 -->
  <div class="sidebar-explorer">
    <!-- TOC导航 -->
    <div class="explorer-section">
      <div class="section-header">
        <i class="fas fa-list"></i>
        <span>TABLE OF CONTENTS</span>
      </div>
      <div class="section-content">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Traverse"><span class="toc-text">Traverse</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pre-order-Traverse"><span class="toc-text">Pre-order Traverse</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#In-Order-Traverse"><span class="toc-text">In-Order Traverse</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Post-Order-Traverse"><span class="toc-text">Post-Order Traverse</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Methodology-of-solving-Binary-Tree-Problems"><span class="toc-text">Methodology of solving Binary Tree Problems</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Classic-Topics-Problems"><span class="toc-text">Classic Topics &#x2F; Problems</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Lowest-Common-Ancestor"><span class="toc-text">Lowest Common Ancestor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serialized-and-Deseriazlied-Binary-Tree"><span class="toc-text">Serialized and Deseriazlied Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Create-an-BST-from-sorted-array"><span class="toc-text">Create an BST from sorted array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Possible-BSTs"><span class="toc-text">Possible BSTs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFS-Level-Order-Traverse"><span class="toc-text">BFS &#x2F; Level Order Traverse</span></a></li></ol></li></ol>
      </div>
    </div>
    
    <!-- 同分类文章 -->
    
    <div class="explorer-section">
      <div class="section-header">
        <i class="fas fa-folder"></i>
        <span>CATEGORY POSTS</span>
      </div>
      <div class="section-content">
        
          <div class="file">
            <i class="fas fa-file-code"></i>
            <a href="/2023/09/17/Parentheses-Problems/">Parentheses Problems</a>
          </div>
        
          <div class="file">
            <i class="fas fa-file-code"></i>
            <a href="/2023/09/02/Backtracking-Template/">Backtracking Template</a>
          </div>
        
          <div class="file">
            <i class="fas fa-file-code"></i>
            <a href="/2023/08/08/Random-Algorithm/">Random Algorithm</a>
          </div>
        
          <div class="file">
            <i class="fas fa-file-code"></i>
            <a href="/2023/08/06/Fenwick-Tree/">Fenwick Tree</a>
          </div>
        
          <div class="file">
            <i class="fas fa-file-code"></i>
            <a href="/2023/08/06/Segment-Tree/">Segment Tree</a>
          </div>
        
          <div class="file">
            <i class="fas fa-file-code"></i>
            <a href="/2023/08/06/Binary-Search-Templates/">Binary Search Templates</a>
          </div>
        
      </div>
    </div>
    
    
    <!-- 标签列表 -->
    
    <div class="explorer-section">
      <div class="section-header">
        <i class="fas fa-tags"></i>
        <span>ARTICLE TAGS</span>
      </div>
      <div class="section-content">
        
          <div class="tag-item">
            <i class="fas fa-tag"></i>
            <a href="/tags/Binary-Tree/">Binary Tree</a>
            <span class="count">(1)</span>
          </div>
        
      </div>
    </div>
    
  </div>

  <!-- 主要内容区域 -->
  <div class="editor-content">
    <div class="tab-bar">
      <div class="tab active">
        <i class="fas fa-file-alt"></i>
        <span>Binary Tree Topics.md</span>
      </div>
    </div>
    
    <div class="content-area">
      <article class="post-content">
        <div class="post-header">
          <h1>Binary Tree Topics</h1>
          <div class="post-meta">
            <span class="date">
              <i class="fas fa-calendar-alt"></i>
              2023-08-06
            </span>            
              <span class="categories">
                <i class="fas fa-folder"></i>
                <div class="categories-list">
                  <ul class="category-item-post-list"><li class="category-item-post-list-item"><a class="category-item-post-list-link" href="/categories/Algorithm/">Algorithm</a></li></ul>
                </div>
              </span>
            
            
              <span class="tags">
                <i class="fas fa-tags"></i>
                <div class="tags-list">
                  <ul class="tag-item-post-list" itemprop="keywords"><li class="tag-item-post-list-item"><a class="tag-item-post-list-link" href="/tags/Binary-Tree/" rel="tag">Binary Tree</a></li></ul>
                </div>
              </span>
            
          </div>
        </div>
        
        <div class="post-body vscode-markdown">
          <h2 id="Traverse"><a href="#Traverse" class="headerlink" title="Traverse"></a>Traverse</h2><p>There’re a lot intereting topics about the traverse of binary tree like the in-order traverse of BST is a sorted sequence. And we may also want to know how to conduct a level tarverse(using queue) and it’s the fundamental of doing Breadth First Search(BFS). We will discuss these topics as well when we go through each section below.<br><img src="https://i.ytimg.com/vi/WLvU5EQVZqY/maxresdefault.jpg" alt="traverse"></p>
<h3 id="Pre-order-Traverse"><a href="#Pre-order-Traverse" class="headerlink" title="Pre-order Traverse"></a>Pre-order Traverse</h3><p>Pre-order traverse will visit root node -&gt; left child -&gt; right child.</p>
<h3 id="In-Order-Traverse"><a href="#In-Order-Traverse" class="headerlink" title="In-Order Traverse"></a>In-Order Traverse</h3><p>In-order traverse will visit left child -&gt; root node -&gt; right child. The in-order traverse of BST will return a sorted array.</p>
<h3 id="Post-Order-Traverse"><a href="#Post-Order-Traverse" class="headerlink" title="Post-Order Traverse"></a>Post-Order Traverse</h3><p>In-order traverse will visit left child -&gt; right node -&gt; root child.</p>
<blockquote>
<p>To determine a binary tree, we need in-order sequence + pre-order &#x2F; post-order sequence.</p>
</blockquote>
<h3 id="Methodology-of-solving-Binary-Tree-Problems"><a href="#Methodology-of-solving-Binary-Tree-Problems" class="headerlink" title="Methodology of solving Binary Tree Problems"></a>Methodology of solving Binary Tree Problems</h3><p>One important observation is that when we take a look at the position of root node, from pre-order to post-order, it goes from the first to the last. Since we always visit left child before visiting right child. We can treat the difference among different traverses is only <em><strong>when to do operation on root node</strong></em>.</p>
<p>Then we can formulate questions into several scenarios:</p>
<ol>
<li>To do the operation on root node, you need to do the operation on left subtree and right subtree first. (Merge Sort)</li>
<li>To do the operation on root node, you need to do operation on its parent node first. (Get the depth of Binary Tree)</li>
<li>To do the operation on root node, you need to do the operation on left&#x2F;right subtree first. (Check BST)</li>
</ol>
<p>The above three scenarios roughly covered all three traverse methods. Given a problem, we need to pay attention that <strong>what is the operation for a given node</strong>, and <em><strong>when to do it. Pre-order, In-order or Post-order</strong></em> ?</p>
<blockquote>
<p>Binary Search Tree(BST) is a kind of special Binary Tree that for a given root node the left subtree only contains nodes with value less than root node, and right subtree only contains nodes with value greater than root node.</p>
</blockquote>
<h2 id="Classic-Topics-Problems"><a href="#Classic-Topics-Problems" class="headerlink" title="Classic Topics &#x2F; Problems"></a>Classic Topics &#x2F; Problems</h2><p>Here are some famous topics and problems that you may want to know.</p>
<h3 id="Lowest-Common-Ancestor"><a href="#Lowest-Common-Ancestor" class="headerlink" title="Lowest Common Ancestor"></a>Lowest Common Ancestor</h3><p>Lowest Common Ancestor problem is trying to get the lowest common ancestor node of two given nodes.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNoe t1, TreeNode t2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span> || root == t1 || root == t2) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">l</span> <span class="operator">=</span> lowestCommonAncestor(root.left, t1, t2);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">r</span> <span class="operator">=</span> lowestCommonAncestor(root.right, t1, t2);</span><br><span class="line">    <span class="keyword">if</span>(l != <span class="literal">null</span> &amp;&amp; r != <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l != <span class="literal">null</span>) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(r != <span class="literal">null</span>) <span class="keyword">return</span> r;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>To analysis the solution in a way that fit into the 3 scenarios mentioned above. Let’s think about what operation do we need to do for a single node.<br>Basically, we need to traverse every node in the binary tree to determine whether the node is the LCA that we want. For a given node, LCA could be this node, but to confirm this, we need to make sure that both target nodes are within it’s subtree. Which means we can only confirm this unless we finish checking it’s left subtree and right subtree. Which means it’s actually a post-order traverse.</p>
<h3 id="Serialized-and-Deseriazlied-Binary-Tree"><a href="#Serialized-and-Deseriazlied-Binary-Tree" class="headerlink" title="Serialized and Deseriazlied Binary Tree"></a>Serialized and Deseriazlied Binary Tree</h3><h3 id="Create-an-BST-from-sorted-array"><a href="#Create-an-BST-from-sorted-array" class="headerlink" title="Create an BST from sorted array"></a>Create an BST from sorted array</h3><p>Creating an BST from sorte array is another interesting topic.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">buildBST</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(left == right) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(array[left]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> buildBST(array, left, mid - <span class="number">1</span>);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> buildBST(array, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(arr[mid]);</span><br><span class="line">    root.left = left;</span><br><span class="line">    root.right = right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Possible-BSTs"><a href="#Possible-BSTs" class="headerlink" title="Possible BSTs"></a>Possible BSTs</h3><p>Given an sorted array, return all possible BSTs.</p>
<h3 id="BFS-Level-Order-Traverse"><a href="#BFS-Level-Order-Traverse" class="headerlink" title="BFS &#x2F; Level Order Traverse"></a>BFS &#x2F; Level Order Traverse</h3><p>Breadth First Search &#x2F; Level order traverse tries to scan each level and print the value.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            System.out.print(current.val);</span><br><span class="line">            <span class="keyword">if</span>(current.left != <span class="literal">null</span>) q.offer(current.left);</span><br><span class="line">            <span class="keyword">if</span>(current.right != <span class="literal">null</span>) q.offer(current.right);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(current.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Level order traverse can be treated as an extended variant of Pre-order traverse. As for per-order traverse, we do operation on the single root node and then move to its left child and right child. But for level traverse, we can treat the nodes at the same level as a node and after we finish doing operations on this “Big Node”, we move to its child.</p>

        </div>
        
        <!-- 文章导航 -->
        <nav class="post-nav">
          
            <a class="prev" href="/2023/08/06/System-Design-Fundamentals/">
              <i class="fas fa-chevron-left"></i>
              System Design Fundamentals
            </a>
          
          
            <a class="next" href="/2023/08/06/Binary-Exponentiation/">
              Binary Exponentiation
              <i class="fas fa-chevron-right"></i>
            </a>
          
        </nav>
      </article>
    </div>
  </div>
</div>

    </div>
    <footer class="footer">
  <div class="status-bar">
    <div class="status-item">
      <i class="fas fa-code-branch"></i>
      master
    </div>
    <div class="status-item">
      <i class="fas fa-sync"></i>
      Tuntun
    </div>
    <div class="status-item">
      <i class="fas fa-clock"></i>
      2025-04-18
    </div>
    <div class="status-item">
      Designed By&nbsp; <a href="https://github.com/B143KC47" target="_blank"> BlackCat</a>
    </div>
    <div class="status-item github">
      <a href="#" target="_blank">
        <i class="fab fa-github"></i>
      </a>
    </div>
  </div>
</footer>

    
    <!-- 全局配置 -->
    <script>
      window.HEXO_CONFIG = {
        language: "en",
        root: "/"
      };
      
      // 特定于搜索的配置
      window.VSC4T_SEARCH = {
        root: "/"
      };
    </script>
    
    <script src="//cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/highlight.js@11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <!-- 这里可以放置自定义脚本 -->
<script>
document.addEventListener('DOMContentLoaded', (event) => {
  // Apply smooth scroll to non-TOC anchor links
  document.querySelectorAll('a[href^="#"]:not(.toc-link)').forEach(anchor => {
    anchor.addEventListener('click', function (e) {
      e.preventDefault();
      // Check if querySelector is valid before using it
      try {
        const targetSelector = this.getAttribute('href');
        // Basic check for potentially invalid selectors (though not exhaustive)
        if (targetSelector && targetSelector.length > 1) { 
          const targetElement = document.querySelector(targetSelector);
          if (targetElement) {
            targetElement.scrollIntoView({
              behavior: 'smooth'
            });
          } else {
            console.warn('Smooth scroll target not found:', targetSelector);
          }
        } else {
           console.warn('Invalid href for smooth scroll:', targetSelector);
        }
      } catch (error) {
        console.error('Error during smooth scroll:', error, 'Selector:', this.getAttribute('href'));
        // Fallback or alternative behavior if needed
        // For example, try getElementById if it's just an ID
        const targetId = this.getAttribute('href').slice(1);
        try {
            const targetElementById = document.getElementById(decodeURIComponent(targetId));
            if (targetElementById) {
                targetElementById.scrollIntoView({ behavior: 'smooth' });
            }
        } catch (idError) {
             console.error('Fallback getElementById also failed:', idError);
        }
      }
    });
  });
});
</script>
<script src="https://raw.githubusercontent.com/jgallen23/toc/greenkeeper/update-all/dist/toc.min.js"></script>

<!-- Scripts -->
<script>
  // 将语言文件中的翻译传递给前端
  window.HEXO_CONFIG = {
    language: "en",
    search_placeholder: "Type to search...",
    search_no_results: "No results found",
    search_result: "result",
    search_results: "results",
    search_results_found: "Found undefined results",
    search_in: "Search in",
    search_in_title: "Title",
    search_in_content: "Content",
    search_in_tags: "Tags",
    search_in_categories: "Categories",
    search_filters: "Search Filters",
    search_recent: "Recent Searches",
    search_clear: "Clear",
    search_loading: "Loading...",
    search_error: "Error loading search data"
  };
</script>



<!-- 添加所有需要的脚本 -->
<script src="/js/main.js"></script>
<script src="/js/search.js"></script>


    <script>
      // 移动端菜单切换
      $(document).ready(function() {
        $('.mobile-menu-toggle').click(function() {
          $('.sidebar-explorer').toggleClass('show');
        });
      });
    </script>
  </body>
</html>
